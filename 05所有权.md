# 什么是所有权？
所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；在另一些语言中，开发者必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序。

## 栈与堆
入栈比在堆上分配内存要快，因为在堆上分配内存需要在运行时找到一块足够大的空内存来放置数据，而且这个过程可能会在堆上留下一些碎片。访问堆上的数据也比访问栈上的数据要慢，因为必须通过指针来访问堆上的数据。现代处理器在内存中跳转的速度非常快，但是仍然比直接访问栈上的数据要慢。

跟踪哪部分代码正在使用堆上的哪些数据，最大限度地减少堆上的重复数据量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的

## 所有权规则
- rust中的每一个值都有一个被称为其所有者(owner)的变量
- 值在任一时刻有且只有一个所有者
- 当所有者(变量)离开作用域，这个值将被丢弃

string类型是存储在堆中的，可以使用from函数基于字符串字面量来创建String
```rust
let s = String::from("hello");
```

## 内存与分配
对于String类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一个在编译时未知大小的内存来存放内容，这意味着：
- 必须在运行时向内存分配器请求内存
- 需要一个当我们处理完String将内存返回给分配器的方法
  
```rust
fn main() {
    {
        let s = String::from("hello"); // 从此处起，s 开始有效

        // 使用 s
    }                                  // 此作用域已结束，
                                       // s 不再有效
}
```
当s离开作用域时，rust自动调用drop函数，释放内存 rust在结尾的}处自动调用drop


## rust在拷贝字符类型时，不会简单的使用2个指针指向同一个地址
```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
}

```
当 s2 和 s1 离开作用域，他们都会尝试释放相同的内存。这是一个叫做二次释放（double free）的错误 所以rust在let s2 = s1 之后 会将s1无效化，称之为移动

如果确实需要深度克隆，可以使用一个叫做clone的通用函数

rust有一个叫做copy trait的特殊标注 可以用在类似整形这样的存储在栈上的类型，如果一个类型实现了copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用

**返回值也可以转移所有权**
