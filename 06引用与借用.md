# 引用就是指针
&符号就是引用，他们允许你使用值但不获取其所有权
解引用使用的是*符号

&s1 语法让我们创建一个 指向 值 s1 的引用，但是并不拥有它。因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。
同理，函数签名使用 & 来表明参数 s 的类型是一个引用

本质上 引用也是不可变的 如果需要改变值 需要使用&mut
不过可变引用有一个很大的限制：在同一时间，只能有一个对某一特定数据的可变引用。尝试创建两个可变引用的代码将会失败

不然则会引发数据竞争，它由这三个行为造成：

- 两个或更多指针同时访问同一数据。
- 至少有一个指针被用来写入数据。
- 没有同步数据访问的机制。

**我们也不能在拥有不可变时同时拥有可变**
多个不可变引用是被允许的

## 悬垂引用
```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String { // dangle 返回一个字符串的引用

    let s = String::from("hello"); // s 是一个新字符串

    &s // 返回字符串 s 的引用
} // 这里 s 离开作用域并被丢弃。其内存被释放。
  // 危险！
```
解决办法是直接返回String 
