# 数据类型
rust的每个值都有确切的数据类型

# 标量类型
rust有4个基本类型 整形 浮点型 布尔 和字符
## 整形
长度	有符号类型	无符号类型
8 位	  i8	        u8
16 位	  i16	        u16
32 位	  i32	        u32
64 位	  i64	        u64
128 位	i128	      u128
arch	  isize	      usize

### 整型溢出
比如u8 可以存放0-255 当你修改为256 则会发生整形移出 在debug时会产生panic 在使用构建模式时会进行用补码包裹的操作 大于该类型最大值的数值会被“包裹”成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0 i8 则是 -256


要显式处理溢出的可能性，可以使用标准库针对原始数字类型提供的以下一系列方法：

使用 wrapping_* 方法在所有模式下进行包裹，例如 wrapping_add
如果使用 checked_* 方法时发生溢出，则返回 None 值
使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
使用 saturating_* 方法使值达到最小值或最大值

## 浮点类型
f32-f64 他们的大小分别为32-64 默认浮点类型都是f64

## 复合类型
### 元组类型
元组的长度是固定的，声明后就无法增长或者缩小
```rust
fn main(){
  let tup:(i32, f64, u8) = (600, 5.2, 1)
}
```
变量 tup 绑定到整个元组，因为元组被认作是单个复合元素。 想从元组中获取个别值，我们可以使用模式匹配来解构（destructure）元组的一个值
```rust
fn main(){
  let tup:(i32, f64, u8) = (600, 5.2, 1);
   let (x, y, z) = tup;
}
```

通过模式匹配进行解构外，我们还可以使用一个句点(.)连上要访问的值的**索引**
元祖第一个索引为0

没有任何值的元组**()**是一种特殊的类型，只有一个值，也写成()。改类型被称为单元类型(unit type)。 该值被称为单元值，如果表达式不返回其他值，就隐式返回单元值

## 数组类型
rust中的数组具有**固定**长度
当你希望将数据分配到栈而不是堆时，或者当你希望始终确保具有固定的元素时

使用方括号编写数组的类型，其中包含每个元素的类型、分号，然后是数组中的元素数，如下所示：
```rust
fn main(){
  let a: [i32; 5] = [1, 2, 3, 4, 5];
}
```

如果要为每个数组创建相同值的数组，可以指定初始值，后跟分号，然后指定长度
```rust
fn main(){
  let a = [3; 5]
}
```
等同于let a = [3, 3, 3, 3, 3]

当你尝试使用索引访问元素时，Rust 将检查你指定的索引是否小于数组长度。如果索引大于或等于数组长度，Rust 会出现 panic
